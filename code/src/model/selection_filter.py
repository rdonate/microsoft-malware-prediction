#! - * - coding UTF-8 - * -

from src.mongo.database import DataBaseMongo
from pymongo import ASCENDING,DESCENDING
import numpy as np
from pymongo.errors import CursorNotFound



def calculateDiscreeting(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collections_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collections_discreeting.drop()
    discrete_feature = np.reshape(np.arange(0, lenghtDB, dtype=int), (1, lenghtDB))
    processed = 0
    while True:
        query = collection_features.aggregate([{'$sort': {'feature' : 1,
                                                          'n_count': -1,
                                                          'label': -1}},
                                               {'$group': {'_id': '$feature',
                                                           'data': {'$addToSet': {'index': '$index_file',
                                                                                  'label': '$label'}}}},
                                               {'$skip':processed}],
                                              allowDiskUse=True)
        try:
            for value in query:
                processed+=1
                discrete = list()
                part = list()
                num_part = 1
                length_value = len(value['data'])
                if length_value <= 2:
                    continue
                list_index = [index for index in range(lenghtDB)]
                data_feature = np.zeros(lenghtDB, dtype=int)
                label_element_prior = value['data'][0]['label']
                index_element_prior = value['data'][0]['index']
                list_index.remove(index_element_prior)
                part.append(index_element_prior)
                data_feature[index_element_prior]=num_part
                label_element = value['data'][1]['label']
                index_element = value['data'][1]['index']
                list_index.remove(index_element)
                for index in range(2, length_value):
                    if ((not (label_element_prior == label_element)) or (not (label_element == value['data'][index]['label']))):
                        discrete.append(part)
                        part = list()
                        num_part+=1
                    part.append(index_element)
                    data_feature[index_element]=num_part
                    label_element_prior, index_element_prior = label_element, index_element
                    label_element = value['data'][index]['label']
                    index_element = value['data'][index]['index']
                    list_index.remove(index_element)
                part.append(index_element)
                data_feature[index_element]=num_part
                discrete.append(part)
                size = 0
                for sub_part in discrete:
                    size += len(sub_part)
                assert size == length_value, "Reveiw discreeting."
                if len(list_index) > 0:
                    discrete.append(list_index)
                    num_part+=1
                    data_feature[list_index]=num_part
                entropy_feature = calculateEntropy(data_feature, discrete_feature, num_part)
                collections_discreeting.insert_one(
                    {'feature': value['_id'], 'num_files': length_value, 'entropy_feature':entropy_feature, 'kind':value['kind'], 'discreeting': discrete, 'k': len(discrete)})
            query.close()
            break
        except CursorNotFound:
            continue
    del db



def calculateRanking(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, num_features, lenghtDB):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in
                     collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2])
    collection_ranking.drop()
    collection_aux_ranking = db.selectCollection(prefix_collection + '_aux_' + namesCollections[2])
    collection_aux_ranking.drop()
    collection_discreeting.aggregate([{'$match': {}}, {'$out': prefix_collection + '_aux_' + namesCollections[2]}])
    collection_aux_ranking.create_index([('feature', ASCENDING)], unique=True)
    del collection_discreeting
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    collection_ranking_su.drop()
    collection_ranking_su.create_index([('feature_prior', ASCENDING),('feature', ASCENDING)], unique=True)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_mi')
    discrete=[[i for i in range(lenghtDB)]]
    entropy_class = calculateEntropy(data, discrete, 9)
    feature_prior=('label', discrete, entropy_class)
    del discrete, entropy_class
    for index in range(num_features):
        processed1 = 0
        while True:
            query1 = collection_aux_ranking.aggregate(
                [{'$sort': {'feature': 1}}, {'$project': {'_id': 0, 'feature': 1, 'entropy_feature':1, 'discreeting': 1}},{'$skip':processed1}], allowDiskUse=True)
            try:
                for feature1 in query1:
                    calculateRankingSU(ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2] + '_su', data, 9, feature_prior, feature1)
                    processed1+=1
                query1.close()
                break
            except CursorNotFound:
                continue
        query_ranking = collection_ranking_su.aggregate(
            [{'$lookup':{'from':'train_rankingFeatures',
                         'localField':'feature',
                         'foreignField':'feature',
                         'as':'ranking'}},
             {'$unwind':'$ranking'},
             {'$group': {'_id': None, 'total_su': {'$sum': '$su'}, 'features': {'$addToSet': '$feature'}}},
             {'$project': {'_id': 0}}], allowDiskUse=True)
        try:
            elements_ranking = query_ranking.next()
        except Exception as e:
            elements_ranking = {'total_su': 0, 'features': []}
        del query1, feature1, processed1
        processed2=0
        while True:
            try:
                query2 = collection_ranking_su.aggregate(
                    [{'$match':{'feature_prior':feature_prior[0]}},
                     {'$sort': {'feature': 1}},
                     {'$skip':processed2}], allowDiskUse=True)
                collection_ranking_mi.drop()
                collection_ranking_mi.create_index([('mi', DESCENDING), ('feature', ASCENDING)])
                for feature2 in query2:
                    calculateRankingMI(ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], elements_ranking, feature2)
                    processed2+=1
                query2.close()
                break
            except CursorNotFound:
                continue
        del feature2, query2, processed2
        best_mi = collection_ranking_mi.aggregate([{'$sort':{'mi':-1, 'feature':1}},{'$project':{'_id':0}},{'$limit':1}],allowDiskUse=True).next()
        best_mi['position'] = index
        feature_prior = (best_mi['feature'], best_mi['discreeting'], best_mi['entropy_class_feature'])
        collection_ranking.insert_one(best_mi)
        collection_aux_ranking.delete_one({'feature':best_mi['feature']})
    del db


def calculate_num_labels(data, array, labels):
    data_labels = np.ones(labels)
    for value in data[list(array)]:
        if value > 0:
            data_labels[value - 1] += 1
    return data_labels


def calculateEntropy(data, discrete, labels):
    entropy = np.zeros(len(discrete))
    total_elements = 0
    for index, array in enumerate(discrete):
        data_labels = calculate_num_labels(data, array, labels)
        num_elements_array = np.sum(data_labels)
        total_elements += num_elements_array
        data_labels = data_labels / num_elements_array
        entropy[index] = num_elements_array * (-np.sum(data_labels * np.log(data_labels)))
    return np.sum(entropy / total_elements)


def calculateRankingSU(ip_Server_Mongo, db_Name, prefix_collection, name_collection, data, num_labels, feature_prior, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection)
    entropy_class_feature = calculateEntropy(data, feature['discreeting'], num_labels)
    su = (2*(feature_prior[2] - entropy_class_feature))/ (feature_prior[2] + feature['entropy_feature'])
    collection_ranking_su.insert_one({'feature':feature['feature'], 'feature_prior':feature_prior[0], 'discreeting': feature['discreeting'], 'su':su, 'entropy_class_feature':entropy_class_feature})
    del db, collection_ranking_su

def calculateRankingMI(ip_Server_Mongo, db_Name, prefix_collection, name_collection, elements_ranking, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + name_collection + '_mi')
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    array = list(elements_ranking['features'])
    array.append(feature['feature'])
    query_su = collection_ranking_su.aggregate([{'$match': {'feature_prior': {'$ne': 'label'},
                                                            'feature':{'$in':array}}},
                                                {'$group': {'_id': None,
                                                            'total_su': {'$sum': '$su'}}}], allowDiskUse=True)
    try:
        feature_su = query_su.next()['total_su']
    except Exception:
        feature_su = 0
    mi = elements_ranking['total_su']+collection_ranking_su.find_one({'feature':feature['feature'],'feature_prior':'label'})['su'] -(0.5*feature_su)
    feature['mi']=mi
    collection_ranking_mi.insert_one(feature)
    del db, collection_ranking_su, collection_ranking_mi
